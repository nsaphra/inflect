#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Outputs a fully inflected version of a lemmatized test set (provided on STDIN). 
If training data is provided, it will use a unigram model to select the form.

usage: cat LEMMA_FILE | python inflect
       [-t TRAINING_PREFIX] [-l LEMMA_SUFFIX] [-w WORD_SUFFIX]
"""

import argparse
import codecs
import sys
import os
from collections import defaultdict
from itertools import izip

PARSER = argparse.ArgumentParser(description="Inflect a lemmatized corpus")
PARSER.add_argument("-t", type=str, default="data/train", help="training data prefix")
PARSER.add_argument("-l", type=str, default="lemma", help="lemma file suffix")
PARSER.add_argument("-w", type=str, default="form", help="word file suffix")
args = PARSER.parse_args()

# Python sucks at UTF-8
sys.stdout = codecs.getwriter('utf-8')(sys.stdout) 
sys.stdin = codecs.getreader('utf-8')(sys.stdin) 

# Build a model on the training data
LEMMATA = defaultdict(defaultdict)
if args.t:
    def combine(a, b): return '%s.%s' % (a, b)
    def utf8read(file): return codecs.open(file, 'r', 'utf-8')
    for words, lemmata in izip(utf8read(combine(args.t, args.w)), utf8read(combine(args.t, args.l))):
        for word, lemma in izip(words.rstrip().split(), lemmata.rstrip().split()):
            LEMMATA[lemma][word] = LEMMATA[lemma].get(word,0) + 1

def best_inflection(lemma):
    if LEMMATA.has_key(lemma):
        return sorted(LEMMATA[lemma].keys(), lambda x,y: cmp(LEMMATA[lemma][y], LEMMATA[lemma][x]))[0]
    return lemma

# Inflect STDIN
for line in sys.stdin:
    print ' '.join([best_inflection(x) for x in line.rstrip().split()])
